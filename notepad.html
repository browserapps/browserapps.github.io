<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Notepad</title>
<style>
body, html {
margin: 0;
padding: 0;
width: 100%;
height: 100%;
background-color: #000;
color: #eee;
font-family: monospace;
font-size: 16px;
}
#editor {
width: 100%;
height: 100%;
padding: 0;
box-sizing: border-box;
outline: none;
white-space: pre-wrap;
word-wrap: break-word;
overflow-y: auto;
}
#editor img {
max-width: 100%;
min-width: 100%;
height: auto;
margin: 0;
display: block;
}
#controls {
position: fixed;
top: 15px;
right: 20px;
z-index: 100;
}
#controls button {
background-color: #333;
color: #fff;
border: 1px solid #555;
padding: 8px 12px;
cursor: pointer;
font-family: monospace;
margin-left: 10px;
}
#controls button:hover {
background-color: #444;
}
</style>
</head>
<body>
<input type="file" id="fileInput" accept=".txt,.encrypted" style="display:none;">
<div id="controls">
<button id="saveButton">Save Encrypted Note</button>
<button id="openButton">Open Encrypted Note</button>
</div>
<div id="editor" contenteditable="true" spellcheck="false" autofocus="true"></div>
<script>
const editor = document.getElementById('editor');
const saveButton = document.getElementById('saveButton');
const openButton = document.getElementById('openButton');
const fileInput = document.getElementById('fileInput');
const CRYPTO_PARAMS = {
name: 'AES-GCM',
iterations: 100000,
saltLength: 16,
ivLength: 12,
keyLength: 256
};
editor.addEventListener('paste', (e) => {
e.preventDefault();
const items = (e.clipboardData || e.originalEvent.clipboardData).items;
let foundImage = false;
for (const item of items) {
if (item.type.indexOf('image') === 0) {
foundImage = true;
const blob = item.getAsFile();
const reader = new FileReader();
reader.onload = (event) => {
const img = document.createElement('img');
img.src = event.target.result;
const selection = window.getSelection();
if (selection.rangeCount > 0) {
const range = selection.getRangeAt(0);
range.deleteContents();
range.insertNode(img);
range.setStartAfter(img);
selection.removeAllRanges();
selection.addRange(range);
} else {
editor.appendChild(img);
}
};
reader.readAsDataURL(blob);
}
}
if (!foundImage) {
const text = (e.clipboardData || e.originalEvent.clipboardData).getData('text/plain');
document.execCommand('insertText', false, text);
}
});
saveButton.addEventListener('click', async () => {
const password = prompt("Enter a password to encrypt this note:");
if (!password) {
alert("Save cancelled. No password provided.");
return;
}
try {
const content = editor.innerHTML;
const encryptedJson = await encrypt(content, password);
downloadFile(encryptedJson, 'note.encrypted.txt', 'application/json');
} catch (err) {
console.error("Encryption failed:", err);
alert("Error during encryption. Check console for details.");
}
});
openButton.addEventListener('click', () => {
fileInput.click();
});
fileInput.addEventListener('change', (e) => {
const file = e.target.files[0];
if (!file) return;
const password = prompt("Enter password to open note:");
if (!password) {
alert("Open cancelled. No password provided.");
return;
}
const reader = new FileReader();
reader.onload = async (event) => {
try {
const encryptedJson = event.target.result;
const decryptedHtml = await decrypt(encryptedJson, password);
editor.innerHTML = decryptedHtml;
} catch (err) {
console.error("Decryption failed:", err);
alert("Decryption failed. Wrong password or corrupted file.");
} finally {
fileInput.value = null;
}
};
reader.readAsText(file);
});
async function deriveKey(password, salt) {
const enc = new TextEncoder();
const keyMaterial = await crypto.subtle.importKey(
'raw',
enc.encode(password),
{ name: 'PBKDF2' },
false,
['deriveKey']
);
return crypto.subtle.deriveKey(
{
name: 'PBKDF2',
salt: salt,
iterations: CRYPTO_PARAMS.iterations,
hash: 'SHA-256'
},
keyMaterial,
{ name: CRYPTO_PARAMS.name, length: CRYPTO_PARAMS.keyLength },
true,
['encrypt', 'decrypt']
);
}
async function encrypt(plaintext, password) {
const enc = new TextEncoder();
const data = enc.encode(plaintext);
const salt = crypto.getRandomValues(new Uint8Array(CRYPTO_PARAMS.saltLength));
const iv = crypto.getRandomValues(new Uint8Array(CRYPTO_PARAMS.ivLength));
const key = await deriveKey(password, salt);
const encryptedBuffer = await crypto.subtle.encrypt(
{ name: CRYPTO_PARAMS.name, iv: iv },
key,
data
);
return JSON.stringify({
salt: arrayBufferToBase64(salt),
iv: arrayBufferToBase64(iv),
ciphertext: arrayBufferToBase64(encryptedBuffer)
});
}
async function decrypt(encryptedJson, password) {
const data = JSON.parse(encryptedJson);
const salt = base64ToArrayBuffer(data.salt);
const iv = base64ToArrayBuffer(data.iv);
const ciphertext = base64ToArrayBuffer(data.ciphertext);
const key = await deriveKey(password, salt);
const decryptedBuffer = await crypto.subtle.decrypt(
{ name: CRYPTO_PARAMS.name, iv: iv },
key,
ciphertext
);
const dec = new TextDecoder();
return dec.decode(decryptedBuffer);
}
function downloadFile(content, fileName, contentType) {
const a = document.createElement('a');
const file = new Blob([content], { type: contentType });
a.href = URL.createObjectURL(file);
a.download = fileName;
a.click();
URL.revokeObjectURL(a.href);
}
function arrayBufferToBase64(buffer) {
let binary = '';
const bytes = new Uint8Array(buffer);
const len = bytes.byteLength;
for (let i = 0; i < len; i++) {
binary += String.fromCharCode(bytes[i]);
}
return window.btoa(binary);
}
function base64ToArrayBuffer(base64) {
const binary_string = window.atob(base64);
const len = binary_string.length;
const bytes = new Uint8Array(len);
for (let i = 0; i < len; i++) {
bytes[i] = binary_string.charCodeAt(i);
}
return bytes.buffer;
}
editor.focus();
</script>
</body>
</html>